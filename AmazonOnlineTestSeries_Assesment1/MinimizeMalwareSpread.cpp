int bfs(vector<vector<int>> &graph, unordered_set<int> infectedNodes, int cur)
{
    // Create a queue.
    queue<int> q;
    // Push all initially infected nodes.
    for (int v : infectedNodes)
    {
        q.push(v);
    }

    // Find all infected nodes after the malware spread.
    while (!q.empty())
    {
        int v = q.front();
        q.pop();
        // Run though all the direct connections of 'v'.
        for (int i = 0; i < graph[v].size(); i++)
        {
            if (i != cur && graph[v][i] == 1 && !infectedNodes.count(i))
            {
                // If this true, then mark this node to be infected.
                // Push this node into the queue, and insert it into the HashSet.
                q.push(i);
                infectedNodes.insert(i);
            }
        }
    }

    // HashSet contain all infected nodes after removal of cur, so return size of HashSet.
    return infectedNodes.size();
}

int minMalwareSpread(vector<vector<int>> &graph, vector<int> &initial)
{
    // Write your code here
    unordered_set<int> infectedNodes(initial.begin(), initial.end());
    // Declare variables.
    int ans = 0;
    int minCount = INT_MAX;

    // Run through vector initial.
    for (int cur : initial)
    {
        // Remove current node.
        infectedNodes.erase(cur);
        // Call the bfs to calculate total infected nodes after the malware spread.
        int cnt = bfs(graph, infectedNodes, cur);
        // Update ans.
        if (cnt < minCount || (cnt == minCount && cur < ans))
        {
            minCount = cnt;
            ans = cur;
        }

        // Insert current node.
        infectedNodes.insert(cur);
    }

    return ans;
}